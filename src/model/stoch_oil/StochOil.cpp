#include "src/model/stoch_oil/StochOil.hpp"

#include <valarray>

#include <assert.h>
#include <boost/math/special_functions/expint.hpp>
#include <boost/math/constants/constants.hpp>

using namespace stoch_oil;
using std::valarray;
using boost::math::expint;

StochOil::StochOil()
{
    inv_cond_cov = NULL;
}
StochOil::~StochOil()
{
	delete[] x, h;
}
void StochOil::loadPermAvg(const std::string fileName)
{
    std::ifstream file(fileName.c_str(), std::ifstream::in);
    std::string buf;
    std::string::size_type sz;
    while(buf != "PERMX")
        file >> buf;
    file >> buf;
    while (buf != "/")
    {
        props_sk.perm_grd.push_back(MilliDarcyToM2(5.0 + std::stod(buf, &sz)));
        file >> buf;
    }
    file.close();
}
void StochOil::writeCPS(const int i)
{
    const std::string filename = "snaps/Pres_std_" + std::to_string(i) + ".cps";
    std::ofstream file(filename.c_str(), std::ofstream::out);
    file << "FSASCI 0 1 \"COMPUTED \" 0 - 999.0000\n";
    file << "FSATTR 0 0\n";
    file << "!Grid generated by ResViewII - 3D.6.9.137\n";
    file << "FSLIMI 25.6098 2074.3901 25.6098 2074.3901 46.6893 231.0594\n";
    file << "FSNROW 41 41\n";
    file << "FSXINC " + std::to_string(2100.0 / 41.0) + " " + std::to_string(2100.0 / 41.0) + "\n";

    int counter = 0;
    for (const auto& cell : mesh->cells)
    {
        if (cell.type == elem::QUAD)
        {
            //const int y_id = cell.id % (mesh->num_y + 2);
            //const int x_id = cell.id / (mesh->num_y + 2);
            file << "\t" << P_dim * sqrt(Cp_next[i][cell.id * cellsNum + cell.id]) / BAR_TO_PA;
            counter++;

            if (counter % 5 == 0)
                file << "\n";
        }
    }

    file.close();

    /*if (i == 0)
    {
        const std::string perm_filename = "snaps/Perm.cps";
        std::ofstream perm(perm_filename.c_str(), std::ofstream::out);
        perm << "FSASCI 0 1 \"COMPUTED \" 0 - 999.0000\n";
        perm << "FSATTR 0 0\n";
        perm << "!Grid generated by ResViewII - 3D.6.9.137\n";
        perm << "FSLIMI 0.0 2100.0 0.0 2100.0 1.0 1.0\n";
        perm << "FSNROW 41 41\n";
        perm << "FSXINC " + std::to_string(2100.0 / 41.0) + " " + std::to_string(2100.0 / 41.0) + "\n";

        counter = 0;
        for (const auto& cell : mesh->cells)
        {
            if (cell.type == elem::QUAD)
            {
                const int y_id = cell.id % (mesh->num_y + 2);
                const int x_id = cell.id / (mesh->num_y + 2);
                perm << "\t" << M2toMilliDarcy(props_sk.perm_grd[(mesh->num_y - y_id) * mesh->num_y + (x_id - 1)]) * R_dim * R_dim;
                counter++;

                if (counter % 5 == 0)
                    perm << "\n";
            }
        }
        perm.close();
    }*/
}
void StochOil::setProps(const Properties& props)
{
	R_dim = props.R_dim;
	t_dim = props.t_dim;
	Q_dim = R_dim * R_dim * R_dim / t_dim;

	possible_steps_num = props.possible_steps_num;
	start_time_simple_approx = props.start_time_simple_approx;
	ht = props.ht;
	ht_min = props.ht_min;
	ht_max = props.ht_max;

	props_sk = props.props_sk;
	props_sk.perm = MilliDarcyToM2(props_sk.perm);
    //loadPermAvg("permx.perm9.inc");

	props_oil = props.props_oil;
	props_oil.visc = cPToPaSec(props_oil.visc);

    conditions = props.conditions;
    for(auto& cond : conditions)
        cond.perm = MilliDarcyToM2(cond.perm);

	wells = props.wells;
	for (auto& well : wells)
		for (auto& rate : well.rate)
			rate /= 86400.0;

	mesh = std::make_shared<Mesh>(*new Mesh(props.num_x, props.num_y, props.hx / R_dim, props.hy / R_dim, props.hz / R_dim));
	Volume = mesh.get()->V;
	cellsNum = mesh.get()->num;

	p0_prev.resize(cellsNum);	
	p0_iter.resize(cellsNum);	
	p0_next.resize(cellsNum);

	Cfp.resize(possible_steps_num);
	for (auto& cfp : Cfp)
		cfp.resize(cellsNum * cellsNum, 0.0);
	Cfp_prev = &Cfp[0][0];	Cfp_next = &Cfp[1][0];

	p2_prev.resize(cellsNum);	
	p2_iter.resize(cellsNum);	
	p2_next.resize(cellsNum);

	Cp_prev.resize(possible_steps_num);	
	Cp_next.resize(possible_steps_num);
	for (size_t i = 0; i < possible_steps_num; i++)
	{
		Cp_prev[i].resize(cellsNum * cellsNum, 0.0);
		Cp_next[i].resize(cellsNum * cellsNum, 0.0);
	}

	x = new adouble[cellsNum];		
	h = new adouble[cellsNum]; 

	makeDimLess();
}
void StochOil::makeDimLess()
{
	P_dim = props_sk.p_init;

	ht /= t_dim;
	ht_min /= t_dim;
	ht_max /= t_dim;

	props_sk.p_init /= P_dim;
	props_sk.p_out /= P_dim;
	props_sk.perm /= R_dim * R_dim;
	props_sk.beta /= (1.0 / P_dim);
	props_sk.l_f /= R_dim;
    for (auto& perm : props_sk.perm_grd)
        perm /= R_dim * R_dim;

    for (auto& cond : conditions)
        cond.perm /= R_dim * R_dim;

	for (auto& well : wells)
	{
		well.rw /= R_dim;
		well.period /= t_dim;
		well.pwf /= P_dim;
		well.rate /= Q_dim;
	}

	props_oil.visc /= P_dim * t_dim;
	props_oil.p_ref /= P_dim;
	props_oil.beta /= (1.0 / P_dim);
	props_oil.rho_stc /= (P_dim * t_dim * t_dim / R_dim / R_dim);
}
void StochOil::setInitialState()
{
	for (size_t i = 0; i < cellsNum; i++)
	{
		const auto& cell = mesh->cells[i];
		p0_prev[i] = p0_iter[i] = p0_next[i] = props_sk.p_init;
		p2_prev[i] = p2_iter[i] = p2_next[i] = 0.0;
	}

	for (size_t i = 0; i < possible_steps_num; i++)
		Cfp[i] = Cp_prev[i] = Cp_next[i] = 0.0;

    Favg.resize(cellsNum, 0.0);
    Cf.resize(cellsNum);
    std::for_each(Cf.begin(), Cf.end(), [&](std::vector<double>& vec) { vec.resize(cellsNum, 0.0); });
    for (int i = 0; i < cellsNum; i++)
    {
        const Cell& cell1 = mesh->cells[i];
        Favg[i] = getFavg_prior(cell1);
        for (int j = 0; j < cellsNum; j++)
            Cf[i][j] = getCf_prior(cell1, mesh->cells[j]);
    }
    // Conditioning
    calculateConditioning();

    // WI calculation
    for (auto& well : wells)
    {
        const Cell& cell = mesh->cells[well.cell_id];
        well.r_peaceman = 0.28 * sqrt(cell.hx * cell.hx + cell.hy * cell.hy) / 2.0;
        well.WI = 2.0 * M_PI * well.perm * cell.hz / log(well.r_peaceman / well.rw);
    }
}
void StochOil::setPeriod(const int period)
{
	for (auto& well : wells)
	{
		well.cur_period = period;
		well.cur_bound = well.leftBoundIsRate[period];
		if (well.cur_bound)
			well.cur_rate = well.rate[period];
		else
			well.cur_pwf = well.pwf[period];
	}
}
double StochOil::getRate(const Well& well) const
{
	if (well.cur_bound)
		return well.cur_rate;
	else
	{
		double p_cell = p0_next[well.cell_id];
        if(well.isCond)
            return well.WI * (p_cell - well.cur_pwf) / props_oil.visc;
        else
            return well.WI / well.perm * getKg(mesh->cells[well.cell_id]) * ((p_cell - well.cur_pwf) + Cfp_next[well.cell_id * cellsNum + well.cell_id]);
	}
}
double StochOil::getPwf(const Well& well) const
{
	if (well.cur_bound)
	{
        const Cell& cell = mesh->cells[well.cell_id];
		double p_cell = p0_next[well.cell_id];
        if(well.isCond)
            return p_cell + well.cur_rate * props_oil.visc / well.WI;
        else
            return p_cell + well.cur_rate * well.perm / well.WI / getKg(cell) * (1.0 + getSigma2f(cell) / 2.0);
	}
	else
		return well.cur_pwf;
}

adouble StochOil::solveInner_p0(const Cell& cell) const
{
	assert(cell.type == elem::QUAD);
	const auto& next = x[cell.id];
	const auto prev = p0_prev[cell.id];
	
	adouble H;
	H = getS(cell) * (next - prev) / getKg(cell);

	const auto& beta_y_minus = mesh->cells[cell.stencil[1]];
	const auto& beta_y_plus = mesh->cells[cell.stencil[2]];
	const auto& beta_x_minus = mesh->cells[cell.stencil[3]];
	const auto& beta_x_plus = mesh->cells[cell.stencil[4]];

	const auto& nebr_y_minus = x[cell.stencil[1]];
	const auto& nebr_y_plus = x[cell.stencil[2]];
	const auto& nebr_x_minus = x[cell.stencil[3]];
	const auto& nebr_x_plus = x[cell.stencil[4]];

	H -= ht * ((nebr_x_plus - next) / (beta_x_plus.cent.x - cell.cent.x) -
			(next - nebr_x_minus) / (cell.cent.x - beta_x_minus.cent.x)) / cell.hx;

	H -= ht * (log(cell.trans[3] / props_oil.visc) - log(cell.trans[2] / props_oil.visc)) / cell.hx *
			(nebr_x_plus - nebr_x_minus) / (beta_x_plus.cent.x - beta_x_minus.cent.x);

	H -= ht * ((nebr_y_plus - next) / (beta_y_plus.cent.y - cell.cent.y) -
		(next - nebr_y_minus) / (cell.cent.y - beta_y_minus.cent.y)) / cell.hy;

	H -= ht * (log(cell.trans[1] / props_oil.visc) - log(cell.trans[0] / props_oil.visc)) / cell.hy *
		(nebr_y_plus - nebr_y_minus) / (beta_y_plus.cent.y - beta_y_minus.cent.y);

	return H;
}
adouble StochOil::solveBorder_p0(const Cell& cell) const
{
	assert(cell.type == elem::BORDER);
	const auto& beta = mesh->cells[cell.stencil[1]];

	const auto& cur = x[cell.id];
	const auto& nebr = x[cell.stencil[1]];

    return /*(cur - nebr) / P_dim;*/ (cur - (adouble)(props_sk.p_out)) / P_dim;
}
adouble StochOil::solveSource_p0(const Well& well) const
{
	const Cell& cell = mesh->cells[well.cell_id];
	if(well.cur_bound == true)
		return -well.cur_rate * ht / cell.V / getKg(cell);
    else
        return -well.WI / well.perm * (well.cur_pwf - x[cell.id]) * ht / cell.V;
}

adouble StochOil::solveInner_Cfp(const Cell& cell, const Cell& cur_cell) const
{
	assert(cell.type == elem::QUAD);
    adouble next;
    if (cell.id == wells[0].cell_id)
    {
        const Well& well = wells[0];
        const double R = 1154.0 / R_dim;
        const double pD = well.cur_rate / getKg(cell) / 2.0 / M_PI / mesh->hz;
        next = x[cell.id] + getSigma2f(cell) * pD * (expint(-R / props_sk.l_f) - expint(-well.r_peaceman / props_sk.l_f));
    }
    else
        next = x[cell.id];

    const auto prev = Cfp_prev[cur_cell.id * cellsNum + cell.id];

	adouble H;
	H = getS(cell) * (next - prev) / getKg(cell);

	const int& y_minus = cell.stencil[1];
	const int& y_plus = cell.stencil[2];
	const int& x_minus = cell.stencil[3];
	const int& x_plus = cell.stencil[4];

	const auto& beta_y_minus = mesh->cells[y_minus];
	const auto& beta_y_plus = mesh->cells[y_plus];
	const auto& beta_x_minus = mesh->cells[x_minus];
	const auto& beta_x_plus = mesh->cells[x_plus];

	const auto& nebr_y_minus = x[y_minus];
	const auto& nebr_y_plus = x[y_plus];
	const auto& nebr_x_minus = x[x_minus];
	const auto& nebr_x_plus = x[x_plus];

	H -= ht * ((nebr_x_plus - next) / (beta_x_plus.cent.x - cell.cent.x) -
		(next - nebr_x_minus) / (cell.cent.x - beta_x_minus.cent.x)) / cell.hx;

	H -= ht * (log(cell.trans[3] / props_oil.visc) - log(cell.trans[2] / props_oil.visc)) / cell.hx *
		(nebr_x_plus - nebr_x_minus) / (beta_x_plus.cent.x - beta_x_minus.cent.x);

	H -= ht * ((nebr_y_plus - next) / (beta_y_plus.cent.y - cell.cent.y) -
		(next - nebr_y_minus) / (cell.cent.y - beta_y_minus.cent.y)) / cell.hy;

	H -= ht * (log(cell.trans[1] / props_oil.visc) - log(cell.trans[0] / props_oil.visc)) / cell.hy *
		(nebr_y_plus - nebr_y_minus) / (beta_y_plus.cent.y - beta_y_minus.cent.y);

	double H1 = -ht * ((p0_next[x_plus] - p0_next[x_minus]) / (beta_x_plus.cent.x - beta_x_minus.cent.x) *
	(getCf(cur_cell, beta_x_plus) - getCf(cur_cell, beta_x_minus)) / (beta_x_plus.cent.x - beta_x_minus.cent.x) +
					(p0_next[y_plus] - p0_next[y_minus]) / (beta_y_plus.cent.y - beta_y_minus.cent.y) *
	(getCf(cur_cell, beta_y_plus) - getCf(cur_cell, beta_y_minus)) / (beta_y_plus.cent.y - beta_y_minus.cent.y));
	
    double H2 = -getS(cell) / getKg(cell) * (p0_next[cell.id] - p0_prev[cell.id]) * getCf(cur_cell, cell);

    if (cell.id == wells[0].cell_id)
        return H + H2;
    else       
        return H + H1 + H2;
}
adouble StochOil::solveBorder_Cfp(const Cell& cell, const Cell& cur_cell) const
{
	assert(cell.type == elem::BORDER || cur_cell.type == elem::BORDER);
	const auto& beta = mesh->cells[cell.stencil[1]];
    return /*(x[cell.id] - x[beta.id]) / P_dim;*/ x[cell.id] / P_dim;
}
adouble StochOil::solveSource_Cfp(const Well& well, const Cell& cur_cell) const
{
	const Cell& cell = mesh->cells[well.cell_id];
    if (well.cur_bound == true)
        return well.cur_rate * ht / cell.V / getKg(cell) * getCf(cur_cell, cell);
    else
        return well.WI / well.perm * x[cell.id] * ht / cell.V;
}

adouble StochOil::solveInner_p2(const Cell& cell) const
{
	assert(cell.type == elem::QUAD);

	const auto& next = x[cell.id];
	const auto prev = p2_prev[cell.id];

	adouble H;
	H = getS(cell) * (next - prev) / getKg(cell);

	const int& y_minus = cell.stencil[1];
	const int& y_plus = cell.stencil[2];
	const int& x_minus = cell.stencil[3];
	const int& x_plus = cell.stencil[4];

	const auto& beta_y_minus = mesh->cells[y_minus];
	const auto& beta_y_plus = mesh->cells[y_plus];
	const auto& beta_x_minus = mesh->cells[x_minus];
	const auto& beta_x_plus = mesh->cells[x_plus];

	const auto& nebr_y_minus = x[y_minus];
	const auto& nebr_y_plus = x[y_plus];
	const auto& nebr_x_minus = x[x_minus];
	const auto& nebr_x_plus = x[x_plus];

	H -= ht * ((nebr_x_plus - next) / (beta_x_plus.cent.x - cell.cent.x) -
		(next - nebr_x_minus) / (cell.cent.x - beta_x_minus.cent.x)) / cell.hx;

	H -= ht * (log(cell.trans[3] / props_oil.visc) - log(cell.trans[2] / props_oil.visc)) / cell.hx *
		(nebr_x_plus - nebr_x_minus) / (beta_x_plus.cent.x - beta_x_minus.cent.x);

	H -= ht * ((nebr_y_plus - next) / (beta_y_plus.cent.y - cell.cent.y) -
		(next - nebr_y_minus) / (cell.cent.y - beta_y_minus.cent.y)) / cell.hy;

	H -= ht * (log(cell.trans[1] / props_oil.visc) - log(cell.trans[0] / props_oil.visc)) / cell.hy *
		(nebr_y_plus - nebr_y_minus) / (beta_y_plus.cent.y - beta_y_minus.cent.y);

	double H1 = -ht * ((Cfp_next[x_plus * cellsNum + x_plus] - Cfp_next[x_plus * cellsNum + x_minus]) -
						(Cfp_next[x_minus * cellsNum + x_plus] - Cfp_next[x_minus * cellsNum + x_minus])) /
						(beta_x_plus.cent.x - beta_x_minus.cent.x) / (beta_x_plus.cent.x - beta_x_minus.cent.x) - 
				ht * ((Cfp_next[y_plus * cellsNum + y_plus] - Cfp_next[y_plus * cellsNum + y_minus]) -
						(Cfp_next[y_minus * cellsNum + y_plus] - Cfp_next[y_minus * cellsNum + y_minus])) /
						(beta_y_plus.cent.y - beta_y_minus.cent.y) / (beta_y_plus.cent.y - beta_y_minus.cent.y);

	const size_t idx = cell.id * cellsNum + cell.id;
	double H2 = getS(cell) / getKg(cell) * ((p0_next[cell.id] - p0_prev[cell.id]) * getSigma2f(cell) / 2.0 -
							(Cfp_next[idx] - Cfp_prev[idx]));
	return H + H1 + H2;
}
adouble StochOil::solveBorder_p2(const Cell& cell) const
{
	assert(cell.type == elem::BORDER);
	const auto& beta = mesh->cells[cell.stencil[1]];
    return /*(x[cell.id] - x[beta.id]) / P_dim;*/ x[cell.id] / P_dim;
}
adouble StochOil::solveSource_p2(const Well& well) const
{
	const Cell& cell = mesh->cells[well.cell_id];
    if (well.cur_bound == true)
        return -well.cur_rate * ht / cell.V / getKg(cell) * getSigma2f(cell) / 2.0;
    else
        return 0.0;// -well.WI / props_oil.visc * (well.cur_pwf - x[cell.id]) * ht / cell.V / getKg(cell) * getSigma2f(cell) / 2.0;
}

adouble StochOil::solveInner_Cp(const Cell& cell, const Cell& cur_cell, const size_t step_idx, const size_t cur_step_idx) const
{
	assert(cell.type == elem::QUAD && cur_cell.type == elem::QUAD);
	adouble next;
    if (cell.id == wells[0].cell_id)
    {
        const Well& well = wells[0];
        const double R = 1154.0 / R_dim;
        const double a0 = 0.4618344;
        const double pD = well.cur_rate / getKg(cell) / 2.0 / M_PI / mesh->hz;
        const double add = getSigma2f(cell) * pD * pD * ((log(well.r_peaceman * R_dim) * log(well.r_peaceman * R_dim) - log(R * R_dim) * log(R * R_dim)) / 2.0 +
            log(well.r_peaceman / R) * (boost::math::constants::euler<double>() +
                0.5 * log(well.r_peaceman * R / props_sk.l_f / props_sk.l_f)) - (well.r_peaceman - R * a0) / props_sk.l_f);
        next = x[cell.id] - add;
    }
    else
        next = x[cell.id];

	double prev;
	if(step_idx > start_time_simple_approx)
		prev = Cp_prev[step_idx - 1][cur_cell.id * cellsNum + cell.id];
	else
		prev = Cp_next[step_idx - 1][cur_cell.id * cellsNum + cell.id];

	adouble H;
	H = getS(cell) * (next - prev) / getKg(cell);

	const int& y_minus = cell.stencil[1];
	const int& y_plus = cell.stencil[2];
	const int& x_minus = cell.stencil[3];
	const int& x_plus = cell.stencil[4];

	const auto& beta_y_minus = mesh->cells[y_minus];
	const auto& beta_y_plus = mesh->cells[y_plus];
	const auto& beta_x_minus = mesh->cells[x_minus];
	const auto& beta_x_plus = mesh->cells[x_plus];

	const auto& nebr_y_minus = x[y_minus];
	const auto& nebr_y_plus = x[y_plus];
	const auto& nebr_x_minus = x[x_minus];
	const auto& nebr_x_plus = x[x_plus];

	H -= ht * ((nebr_x_plus - next) / (beta_x_plus.cent.x - cell.cent.x) -
		(next - nebr_x_minus) / (cell.cent.x - beta_x_minus.cent.x)) / cell.hx;

	H -= ht * (log(cell.trans[3] / props_oil.visc) - log(cell.trans[2] / props_oil.visc)) / cell.hx *
		(nebr_x_plus - nebr_x_minus) / (beta_x_plus.cent.x - beta_x_minus.cent.x);

	H -= ht * ((nebr_y_plus - next) / (beta_y_plus.cent.y - cell.cent.y) -
		(next - nebr_y_minus) / (cell.cent.y - beta_y_minus.cent.y)) / cell.hy;

	H -= ht * (log(cell.trans[1] / props_oil.visc) - log(cell.trans[0] / props_oil.visc)) / cell.hy *
		(nebr_y_plus - nebr_y_minus) / (beta_y_plus.cent.y - beta_y_minus.cent.y);

	double H1 = -ht * ((p0_next[x_plus] - p0_next[x_minus]) / (beta_x_plus.cent.x - beta_x_minus.cent.x) *
		(Cfp[step_idx][x_plus * cellsNum + cur_cell.id] - Cfp[step_idx][x_minus * cellsNum + cur_cell.id]) / (beta_x_plus.cent.x - beta_x_minus.cent.x) +
		(p0_next[y_plus] - p0_next[y_minus]) / (beta_y_plus.cent.y - beta_y_minus.cent.y) *
		(Cfp[step_idx][y_plus * cellsNum + cur_cell.id] - Cfp[step_idx][y_minus * cellsNum + cur_cell.id]) / (beta_y_plus.cent.y - beta_y_minus.cent.y));

	double H2 = -getS(cell) / getKg(cell) * (p0_next[cell.id] - p0_prev[cell.id]) * Cfp[step_idx][cell.id * cellsNum + cur_cell.id];

    if (cell.id == wells[0].cell_id)
        return H + H2;
    else
        return H + H1 + H2;
}
adouble StochOil::solveBorder_Cp(const Cell& cell, const Cell& cur_cell, const size_t step_idx) const
{
	assert(cell.type == elem::BORDER || cur_cell.type == elem::BORDER);
	const auto& beta = mesh->cells[cell.stencil[1]];
    return /*(x[cell.id] - x[beta.id]) / P_dim;*/ x[cell.id] / P_dim;
}
adouble StochOil::solveSource_Cp(const Well& well, const Cell& cur_cell, const size_t step_idx) const
{
	const Cell& cell = mesh->cells[well.cell_id];
    if (well.cur_bound == true)
        return 0.0;// well.cur_rate * ht / cell.V / getKg(cell) * Cfp[step_idx][cell.id * cellsNum + cur_cell.id];
    else
        return 0.0;// well.WI / props_oil.visc * (well.cur_pwf - x[cell.id]) * ht / cell.V / getKg(cell) * Cfp[step_idx][cell.id * cellsNum + cur_cell.id];
}